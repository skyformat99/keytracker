### 功能

简单高效的 Key/Value 数据存储、读取；支持 Key 层级关系遍历、监控；监控对应变更，监控直接子集、递归子集；使用 [bolt](https://github.com/boltdb/bolt) 引擎，支持持久化；

### 使用
启动 bin/keytracker(.exe) 即可，也可设置以下参数：
* listen - 监听地址，默认 ":7472" 监听所有地址的 7472 端口；
* engine - 存储引擎，目前仅支持 bolt / none 两种，默认使用 bolt 使用 https://github.com/boltdb/bolt 作为数据存储（支持持久化、性能优异），none 使用 golang 内置的 map 作为数据存储（不提供持久化，查询性能较慢）
* logger - 日志等级，默认 debug，可以指定 trace/debug/info/warning/error/fatal 中的任意一个；

### 交互协议

#### 客户端发送数据：

``` javascript
// 1. 设置数据
{"k":"/a/key_1","v":"aaaaa","x":1} // 1 - 临时数据
{"k":"/a/key_2","v":"bbbbb","x":2} // 2/3 - 持久数据
{"k":"/a/key_","v":"bbbbb","x":5} // 5 - 临时后缀数据
{"k":"/a/key_","v":"bbbbb","x":6} // 6/7 - 持久后缀数据
{"k":"/a/key_1","v":null,"x":0} // x 可以是任意小于 256 的值
// 6. 监控数据
{"k":"/a","v":1,"x":256} // 建立子集数据监控 256
{"k":"/a","v":1,"x":257} // 257 +1 当前 KEY 数据监控
{"k":"/a","v":1,"x":258} // 建立循环子集监控 256 + 2
{"k":"/a","v":null,"x":256} // 删除监控 x=256/257/258 相同
// 7. 读取数据
{"k":"/a/key_1","v":null,"x":512} // 读取子集
{"k":"/a","v":null,"x":513} // 读取当前项
{"k":"/a","v":null,"x":514} // 读取循环子集
```

字段 **x** 存在如下值：
* 1 - 设置数据
	* 3 - +2 持久数据，不在断开连接时消失
	* 5 - +4 服务端自动补充名称后缀
	* 7 - +2+4 持久数据，且自动补充名称后缀
* 256 - 添加监控
	* 256 - +0 监控 `/a` 时，仅当 `/a` 对应的值发生变更时触发推送；
	* 257 - +1 监控 `/a` 时，当形如 `/a/key_1` 变更时会触发推送，但 `/a/key_1/key_3` 不会触发，即仅在直接子集时触发；
	* 258 - +2 监控 `/a` 时，当形如 `/a/key_1` 变更时会触发推送，同时 `/a/b/key_2` 也会触发，即所有子集均会触发；
* 512 - 读取数据
	* 512 - +0 读取指定 KEY 的直接子集列表；
	* 513 - +1 读取指定的 KEY；
	* 514 - +2 读取指定 KEY 的循环子集列表；
* 1024 - 列表数据

#### 服务端发送数据

``` javascript
// 1. 数据变更推送
{"k":"/a/key_1","v":"aaaaa","y":0} // 值变更
{"k":"/a/key_1","v":null,"y":0} // 被删除
// 2. 后缀响应
{"k":"/a/key_0000000002","v":"aaaaa","y":1} 
// 3. 监控响应
{"k":"/a/key_1/xxx","v":"aaaaa","y":2}
```

字段 **y** 存在如下值：
* 0 - 监控后数据变更推送，或读取、列表数据；
* 1 - 后缀设置数据项响应；
* 2 - 监控响应，会以此标识推送对应全量数据项；
